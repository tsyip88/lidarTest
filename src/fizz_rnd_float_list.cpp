#include "stats.h"
#include "fizz_rnd_float_list.h"
#include <QtGlobal>
#include <random>
#include <algorithm>
#include "i_random_number_generator.h"

using namespace std;

fizz_rnd_float_list::fizz_rnd_float_list(int N, i_random_number_generator& rng)
{
    initialize(N, rng);
}

fizz_rnd_float_list::~fizz_rnd_float_list()
{
}

stats fizz_rnd_float_list::get_stats(float X)
{
    if(stats_array.empty()) {
        return stats();
    }
    return stats_array[nearest_index(X, 0, stats_array.size() - 1)];
}

// Performs a binary search of a item to find out which item is the closest
// time complexity of O(log(n))
int fizz_rnd_float_list::nearest_index(float X, int left, int right)
{
    if(left == right)
    {
        return left;
    }
    if(left + 1 == right)
    {
        if(abs(X - stats_array[left].Y) < abs(X - stats_array[right].Y))
        {
            return left;
        }
        else
        {
            return right;
        }
    }
    int mid = (left + right)/2;
    if(X > stats_array[mid].Y)
    {
        return nearest_index(X, mid, right);
    }
    else
    {
        return nearest_index(X, left, mid);
    }
}

float fizz_rnd_float_list::generate_random_number(i_random_number_generator& rng)
{
    return rng.generate_float(0.0f, 1.0f);
}

// Caches all the statistically data on construction to prevent full calculations from occurring with every
// call to get_stats.
// Stats are generated by continuously calculating with the following methods:
//      Mean value calculated as numbers are generated using the total sum / total number of items
//      Standard of deviation is calculated by expanding the uncorrected sample standard deviation formula from:
//          https://en.wikipedia.org/wiki/Standard_deviation
//          the sum of squares is maintained to ensure the list does not need to be iterated multiple times
// Total time complexity: O(n) + sort = O(nlog(n))
// Based off the maximum float value of 3.4*10^38 and the maximum sum of squares can be at most 1000*1000 = 10^6,
// The buffer will not overflow given that N is an integer of max val: 32767
void fizz_rnd_float_list::initialize(int N, i_random_number_generator& rng)
{
    if(N <= 0) {
        return;
    }
    rand_array.push_back(generate_random_number(rng));
    stats first;
    first.M = 0;
    first.Y = rand_array.front();
    first.mean = first.Y;
    first.standard_deviation = 0.0f;
    stats_array.push_back(first);

    float sum = first.Y;
    float sum_of_squares = first.Y * first.Y;
    for(int i = 1; i < N; i++) {
        float random_value = generate_random_number(rng);
        rand_array.push_back(random_value);

        sum += random_value;
        sum_of_squares += random_value*random_value;
        stats s;
        s.M = i;
        s.Y = random_value;
        s.mean = sum / (i + 1);
        s.standard_deviation = sqrt((sum_of_squares - 2 * s.mean * sum + (i + 1) * s.mean * s.mean) / (i + 1));
        stats_array.push_back(s);
    }
    sort(stats_array.begin(), stats_array.end(),
        [](const stats& first, const stats& second)->bool{
        return first.Y < second.Y;
    });
}
